# Полная Техническая Спецификация Кода (script.js)

Этот документ содержит исчерпывающее объяснение каждой функции, условия и переменной в файле `script.js`. Предназначен для разработчиков, желающих понять внутреннюю логику проекта до мельчайших деталей.

---

## 1. Глобальные Данные (Data Layer)

Мы не используем внешнюю базу данных. Все данные хранятся в статических константах (массивах объектов). Это делает проект автономным.

### `const films = [...]`
*   **Тип:** `Array<Object>`
*   **Назначение:** Хранит каталог всех фильмов.
*   **Структура объекта:**
    *   `id`: Уникальный номер (для логов или будущей логики).
    *   `title`, `description`: Текстовые данные.
    *   `image`: Путь к файлу. **Важно:** Используется относительный путь `./imgs/...`.
    *   `category`: Строка `'popular'` или `'recommended'`. Используется для фильтрации на главной странице.
    *   `prices`: Объект `{ "CityName": Price }`. Позволяет выводить разную цену для разных городов.

### `const cities = [...]` и `const cinemas = [...]`
*   **Назначение:** Списки городов и кинотеатров. В `cinemas` у каждого кинотеатра есть поле `city`, по которому мы будем их фильтровать.

### `const translations = {...}`
*   **Тип:** `Object` (Dictionary)
*   **Структура:** `{ langCode: { key: value } }`.
*   **Логика:** Ключи (например, `header.main`) используются в HTML-атрибутах `data-i18n`.

---

## 2. Модуль Авторизации (Auth Module)

Этот блок имитирует работу сервера (регистрация/вход).

### Переменные Состояния
```javascript
const users = JSON.parse(localStorage.getItem("users")) || [];
let currentUser = JSON.parse(localStorage.getItem("currentUser")) || null;
```
*   **`users`**: Список всех зарегистрированных пользователей. Загружается из `localStorage` (ключ "users"). Если там пусто — создается пустой массив `[]`.
*   **`currentUser`**: Объект текущего залогиненного пользователя. Если `null` — пользователь гость.

### Функция: `registerUser(name, email, password)`
*   **Аргументы:** Строки данных из формы регистрации.
*   **Логика:**
    1.  **Проверка дубликатов:**
        ```javascript
        if (users.find(u => u.email === email)) ...
        ```
        Метод массива `.find()` ищет первый элемент, где `email` совпадает. Если нашел — возвращает ошибку. Это предотвращает создание двух аккаунтов с одной почтой.
    2.  **Создание:** Создается новый объект `newUser`.
    3.  **Сохранение (БД):** `users.push(newUser)` добавляет в массив.
    4.  **Персистенция (Запись на диск):**
        ```javascript
        localStorage.setItem("users", JSON.stringify(users));
        ```
        Мы превращаем массив в строку JSON и сохраняем в браузере.
    5.  **Авто-логин:** Сразу присваиваем `currentUser = newUser` и сохраняем его в `localStorage`.

### Функция: `loginUser(email, password)`
*   **Логика:**
    1.  Ищет пользователя:
        ```javascript
        const user = users.find(u => u.email === email && u.password === password);
        ```
        Здесь используется логическое И (`&&`). Оба условия должны совпасть.
    2.  Если `user` найден (не `undefined`), сохраняем его в `currentUser` (вход успешен).

### Функция: `logoutUser()`
*   **Логика:**
    1.  Очищает переменную и хранилище (`currentUser = null`, `localStorage.removeItem`).
    2.  **Редирект (Перенаправление):**
        ```javascript
        const isPagesDir = window.location.pathname.includes("/pages/");
        const target = isPagesDir ? "bin.html" : "pages/bin.html";
        window.location.href = target;
        ```
        Скрипт проверяет URL (`window.location.pathname`). Если мы уже в папке `pages`, путь будет просто `bin.html`. Если мы в корне (на главной), путь будет `pages/bin.html`. Это позволяет функции работать корректно с любой страницы сайта.

---

## 3. Инициализация и Состояние (State & Init)

Блок кода выполняется сразу при загрузке скрипта.

```javascript
if(!localStorage.getItem("currentCity")) localStorage.setItem("currentCity", "Astana");
if(!localStorage.getItem("currentLang")) localStorage.setItem("currentLang", "ru");
```
*   **Цель:** Защита от "пустого" состояния. Если пользователь зашел первый раз, мы принудительно ставим ему Астану и Русский язык.

```javascript
let currentCity = localStorage.getItem("currentCity") || "Astana";
let currentLang = localStorage.getItem("currentLang") || "ru";
```
*   **Цель:** Загружаем актуальные данные в переменные для быстрого доступа.

### Функция: `saveState()`
*   **Назначение:** Сохраняет любое изменение глобальных переменных (город, язык) в память.
*   **Важно:** Всегда вызывает `updateUI()` в конце, чтобы интерфейс мгновенно перерисовался.

---

## 4. Рендеринг Карточек Фильмов (Core Render Logic)

### Функция: `createCard(film)`
*   **Назначение:** Генерирует HTML-элемент (div) для одного фильма.
*   **Детали Реализации:**
    1.  **Цена:**
        ```javascript
        const price = film.prices[currentCity] || film.prices["Astana"];
        ```
        Пытается взять цену для текущего города. Если её нет (ключ не найден) — берет цену для Астаны (fallback).
    2.  **Путь к картинке:**
        Снова проверка пути (`isPagesDir`), аналогичная `logoutUser`. Если мы на подстранице, добавляем точку: `.` + путь, чтобы выйти на уровень выше или остаться в контексте.
    3.  **DataSet:**
        ```javascript
        card.dataset.name = film.title;
        card.dataset.price = price;
        ```
        Мы сохраняем данные прямо в HTML-теги как атрибуты `data-name`. Это нужно, чтобы потом при клике "Добавить в корзину" мы могли узнать, на какой именно фильм кликнули, не ища его в массиве `films`.

### Функция: `renderCards(data, containerId)`
*   **Аргументы:**
    *   `data`: Массив фильмов (уже отфильтрованный).
    *   `containerId`: ID элемента, куда вставлять карточки (например, `cards-container`).
*   **Логика:**
    1.  Находит контейнер по ID. Если его нет на этой странице — `return` (выход).
    2.  `container.innerHTML = ""` — **Полная очистка**. Удаляет старые карточки.
    3.  Цикл `.forEach` — создает новую карточку (`createCard`) и добавляет (`appendChild`) в контейнер.

---

## 5. Главный Цикл Обновления UI: `updateUI()`

Это "сердце" фронтенда. Функция вызывается при любых действиях.

### 5.1. Обновление Шапки (Город/Язык)
*   Генерирует выпадающий список городов через цикл `cities.forEach`.
*   Обновляет текст текущего города.
*   Обновляет текст текущего языка. **Условие:**
    ```javascript
    if(currentLang === 'en') langText = 'Eng'; // и т.д.
    ```
    Простой `if/else` для выбора отображаемого сокращения.

### 5.2. Поиск и Фильтрация (Search Logic)
*   Получает текст из инпута `.search`. `value.toLowerCase()` — переводит в нижний регистр для нечувствительного поиска.
*   Получает категорию из селекта `.search-filter` ("all", "popular", и т.д.).
*   **Основной Фильтр:**
    ```javascript
    const filteredFilms = films.filter(film => {
        const matchesQuery = film.title.toLowerCase().includes(query); // Совпадает имя?
        const matchesCategory = category === "all" || film.category === category; // Совпадает категория?
        return matchesQuery && matchesCategory; // И то, и другое должны быть true
    });
    ```
    Метод `.filter()` создает новый массив, оставляя только подходящие элементы. Условие `category === "all"` позволяет пропустить проверку категории ("показывать всё").

### 5.3. Распределение по контейнерам
*   У нас есть 3 контейнера:
    1.  `cards-container` (обычно для "Популярного" на главной).
    2.  `cards-container2` (для "Рекомендаций" на главной).
    3.  `catalog-container` (для каталога, где всё вместе).
*   **Логика:**
    Мы берем наш глобально отфильтрованный список `filteredFilms` и еще раз фильтруем его для конкретных секций:
    ```javascript
    renderCards(filteredFilms.filter(f => f.category === "popular"), "cards-container");
    ```
    Так в секцию "Популярное" попадают *только* популярные фильмы, которые *также* прошли поиск пользователя.

---

## 6. Профиль и Страницы (`renderProfilePage`)

### Функция: `renderProfilePage()`
*   **Guard Clause (Охранное условие):**
    ```javascript
    if (!currentUser) { window.location.href = ...; return; }
    ```
    Если пользователь не залогинен, функция прерывается и перекидывает на страницу входа. Это защищает страницу профиля от неавторизованного доступа.
*   **Template Literals:**
    Использует обратные кавычки `` `...` `` для вставки переменных `${currentUser.name}` прямо в HTML-строку.

---

## 7. Обработка Событий (Event Listeners)

### Глобальный клик (`document.addEventListener("click", ...)`)
Отвечает за интерактивность, используя паттерн **Event Delegation** (Делегирование). Вместо того, чтобы вешать событие на каждую кнопку (которых может быть 100), мы вешаем одно событие на весь документ и смотрим, куда кликнули.

#### Условия внутри клика:
1.  **`.add-to-cart`**:
    *   Ищет `e.target.closest(".card")`. Метод `closest` поднимается вверх по родителям элемента, пока не найдет карточку. Это нужно, так как клик мог прийтись на иконку или текст внутри кнопки.
    *   Читает `dataset.name` и `price`.
    *   Обновляет объект `cartData`.
2.  **`.order-btn`**:
    *   Проверяет `if (!currentUser)`.
    *   Если нет юзера — `alert` и редирект на вход.
3.  **`.lang_change` / `.city_change`**:
    *   Управляет классами `.active` для выпадающих списков.

### Форма Контактов (`contactForm.addEventListener("submit")`)
*   `e.preventDefault()`: Отменяет стандартную перезагрузку страницы браузером.
*   **Валидация:**
    *   Проверяет поля на пустоту (`.trim() === ""`).
    *   Email на наличие `@`.
    *   Чекбокс соглашения (`.checked`).
*   Если есть ошибки — выводит их список в `div`. Если нет — `alert("Success")`.

---

## 8. Корзина (`cartData` и `renderCart`)

*   **`cartData`**: Объект типа `{ "Фильм": { qty: 2, price: 1500 } }`. Использование объекта (словаря) позволяет мгновенно проверять наличие товара по имени (ключу) `cartData[name]`.
*   **`changeQty(name, delta)`**:
    *   Меняет количество. `delta` может быть `+1` или `-1`.
    *   Если `qty <= 0`, удаляет ключ (`delete cartData[name]`).
*   **`renderCart()`**:
    *   Цикл `for (let name in cartData)` бежит по товарам.
    *   Считает `total += item.qty * item.price`.
    *   Генерирует HTML списка.

---

Эта документация покрывает 100% логики файла `script.js`.
